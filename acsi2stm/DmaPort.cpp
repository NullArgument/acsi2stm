/* ACSI2STM Atari hard drive emulator
 * Copyright (C) 2019-2021 by Jean-Matthieu Coulon
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with the program.  If not, see <http://www.gnu.org/licenses/>.
 */

/*
How CS and A1 signals are handled
=================================

Expected behavior
-----------------

CS is generated by the ST, it signals that an IRQ transfer has been executed.
A1 is generated by the ST, when low it signals that the current transfer is
the beginning of a new command.

Command (ST -> STM32)

         ______________         ________        ___
    IRQ                |_______|        |______|
         ___   _____________   _____________   ____
    CS      |_|             |_|             |_|
         __     ___________________________________
    A1     |___|
    
    DATA    [1]             [2]             [3]


Status (STM32 -> ST)

         __         __
    IRQ    |_______|
         _______   ___
    CS          |_|
    
    DATA   [=======]


STM32 implementation
--------------------

Main issues faced in previous versions:

 * The CS pulse is too fast to be reliably polled.
 * A1 and CS must be read at the same time.
 * Data is guaranteed to be available only when the CS pin is low.

In order to sample CS, A1 and D0-D7 pins all at the same time, a hardware
timer and 2 DMA channels are used. In order to sample both CS and A1, the
timer is set in rotating encoder mode.

In encoder mode 2, A1 gives the rotation direction and CS gives the rotation
pulse. A CS pulse is equivalent to rotating the encoder one step in one
direction, then quickly going back to the starting position.

Overview of the setup:
             __________
         DIR|  Timer4  |Underflow
   A1 ----->|TI1       |------------
            |          |            |
        STEP|          |CH3 CC      |
   CS ----->|TI2       |------------+
            |__________|            |
                                    |Trigger (DMA1 CH5+CH7)
                      _______     __V___     __________
                     |       |   |      |   |          |
                     | GPIOB |-->| DMA1 |-->|  Timer4  |
                     |       |   |      |   |  CH4 CC  |
                     |_______|   |______|   |__________|

A CS pulse with A1 low will pulse the timer counter to 1, then back to 0. This
will trigger CH3 compare event.

A CS pulse with A1 high will pulse the timer counter to -1 (65535), then back
to 0. This will trigger the overflow/underflow event.

Both events will trigger a DMA operation that copies GPIOB to the channel 4 CC
value.

Timer4 CH4 is used as a simple buffer because GPIOB is considered as memory by
the STM32 DMA engine and memory to memory copies cannot be triggered by a
timer, so it has to be a memory to peripheral copy. Any unused peripheral
register can be used for this task.


How ACSI DMA is handled (DRQ/ACK pulses and data sampling)
==========================================================

Expected behavior
-----------------

DRQ is generated by the STM32, it triggers a DMA transfer.
ACK is generated by the ST, it tells the STM32 when the data bus is sampled.
DRQ must go high at most 180ns after ACK goes low. Failing to do that will
abort the DMA transfer by the ST.

DMA reads (STM32 -> ST)

          ___              _________
     DRQ     |____________|
          ______________         ___
     ACK                |_______|
    
    DATA                        S

Data seems to be sampled when ACK goes up (marked "S").
The STM32 keeps the data up for the whole transfer (DRQ+ACK), which avoids
risks of reading invalid data.


DMA writes (ST -> STM32)

          ___              _________
     DRQ     |____________|
          ______________         ___
     ACK                |_______|
    
    DATA               [========]

Data is guaranteed to be available during the whole ACK pulse (marked "[==]").


STM32 implementation
--------------------

DRQ and ACK pulses are too fast to use bit banging, even with direct port
access.

The current implementation uses STM32 timers and its DMA engine to process
these signals. Data flow:
             __________
         CLK|          |CH4
  ACK ----->|  Timer1  |-----> PA11 (DRQ)
            |          |
            |          |CH3
            |          |------------
            |__________|            |
                                    |Trigger (DMA1 CH6)
                      _______     __V___     __________
                     |       |   |      |   |          |
                     | GPIOB |-->| DMA1 |-->|  Timer1  |
                     |       |   |      |   |  CH1 CC  |
                     |_______|   |______|   |__________|

 * ACK is used as Timer1 clock.
 * PA11 (DRQ) is used as a PWM output that goes up whenever Timer1 receives a clock tick.
 * Timer1 triggers a STM32 DMA transfer whenever Timer1 receives a clock tick.
 * The STM32 DMA engine copies GPIOB to Timer1 CH1 compare value.
 * Timer1 CH1 is used as a simple buffer because GPIOB is considered as memory
   by the STM32 DMA engine and memory to memory copies cannot be triggered by
   a timer, so it has to be a memory to peripheral copy. Any unused peripheral
   register can be used for this task.
 * If multiple ACK signals are received, this can be detected by having an incorrect
   counter value. This avoids silent data corruption in case of problems. This check is
   only done if ACSI_CAREFUL_DMA is enabled.


DMA read process
----------------

DMA block transfer initialization process:

 * Set Timer1 counter to a high value so DRQ will be high when enabled
 * Enable DRQ in PWM mode (high if Timer1 > 0, low if Timer1 = 0)
 * Enable Timer1

DMA byte read process:

 * Data is put on the data bus.
 * Set Timer1 counter to 0, this will pull DRQ low.
 * When ACK goes low, Timer1 counts to 1.
 * Timer1 counting will set DRQ high.
 * Wait until ACK goes high.

DMA block transfer stop process:

 * Set DRQ pin as input
 * Disable Timer1


DMA write process
-----------------

DMA block transfer initialization process:

 * Set Timer1 counter to a high value so DRQ will be high when enabled
 * Enable DRQ in PWM mode (high if Timer1 > 0, low if Timer1 = 0)
 * Enable Timer1

DMA byte write process:

 * Set Timer1 counter to 0, this will pull DRQ low.
 * When ACK goes low, Timer1 counts to 1.
 * Timer1 counting will set DRQ high.
 * Timer1 counting will trigger the STM32 DMA CH6.
 * The STM32 DMA will copy GPIOB to Timer1 CH1 compare value.
 * Wait until ACK goes high.
 * Read Timer1 CH1 compare value to get the data byte.

DMA block transfer stop process:

 * Set DRQ pin as input
 * Disable Timer1

*/

#include "acsi2stm.h"
#include "Acsi.h"
#include "DmaPort.h"
#include <libmaple/dma.h>

// Timer
#define DMA_TIMER TIMER1_BASE
#define CS_TIMER TIMER4_BASE

void DmaPort::begin() {
  deviceMask = 0;
  dma_init(DMA1);
  setupDrqTimer();
  setupAckDmaTransfer();
  setupGpio();
}

void DmaPort::addDevice(int id) {
  if(id >= 0 && id < 8)
    deviceMask |= 1 << id;
}

void DmaPort::removeDevice(int id) {
  if(id >= 0 && id < 8)
    deviceMask &= ~(1 << id);
}

bool DmaPort::idle() {
  return (GPIOA->regs->IDR & (IRQ_MASK | DRQ_MASK | ACK_MASK)) == IRQ_MASK | DRQ_MASK | ACK_MASK;
}

void DmaPort::waitBusReady() {
  pinMode(CS, INPUT_PULLDOWN);
  pinMode(A1, INPUT_PULLDOWN);

  while((((GPIOB->regs->IDR) | ~(A1_MASK | CS_MASK)) != ~0) || !idle());

  pinMode(CS, INPUT);
  pinMode(A1, INPUT);

  setupCsTimer();
}

bool DmaPort::checkCommand() {
  return (CS_TIMER->SR & TIMER_SR_CC3IF);
}

bool DmaPort::validCommand() {
  return (1 << ((CS_TIMER->CCR4) >> 13) & deviceMask) && idle();
}

uint8_t DmaPort::readCommand() {
  uint8_t cmd = (CS_TIMER->CCR4) >> 8;
  Acsi::verboseHex('[', cmdDeviceId(cmd), ':', cmdCommand(cmd), ']');
  return cmd;
}

uint8_t DmaPort::waitCommand() {
  for(;;) {
    while(!checkCommand());
    if(validCommand())
      break;
    endTransaction();
  }
  return readCommand();
}

void DmaPort::readIrq(uint8_t *bytes, int count) {
  // Disable systick that introduces jitter.
  systick_disable();

  while(count > 0) {
    *bytes = readIrq();
    ++bytes;
    --count;
  }

  // Restore systick
  systick_enable();
}

uint8_t DmaPort::readIrq() {
  Acsi::verbose("[<");

  pullIrq();
  uint8_t byte = waitCs(); // Wait CS pulse and read data
  releaseRq();

  Acsi::verboseHex(byte, ']');

  return byte;
}

void DmaPort::sendIrq(uint8_t byte) {
  Acsi::verboseHex("[>", byte, "]\n");

  // Disable systick that introduces jitter.
  systick_disable();

  acquireDataBus();
  writeData(byte);
  pullIrq();
  waitCs();
  releaseBus();

  // Restore systick
  systick_enable();
}

void DmaPort::readDma(uint8_t *bytes, int count) {
  // Disable systick that introduces jitter.
  systick_disable();

  Acsi::verbose("DMA read ");

  acquireDrq();

  // Unroll for speed
  int i;
  for(i = 0; i <= count - 16; i += 16) {
#define ACSI_READ_BYTE(b) do { \
      DMA_TIMER->CNT = 0; \
      while(DMA_TIMER->CNT == 0); \
      bytes[b] = (uint8_t)(DMA_TIMER->CCR1 >> 8); \
    } while(0)
    ACSI_READ_BYTE(0);
    ACSI_READ_BYTE(1);
    ACSI_READ_BYTE(2);
    ACSI_READ_BYTE(3);
    ACSI_READ_BYTE(4);
    ACSI_READ_BYTE(5);
    ACSI_READ_BYTE(6);
    ACSI_READ_BYTE(7);
    ACSI_READ_BYTE(8);
    ACSI_READ_BYTE(9);
    ACSI_READ_BYTE(10);
    ACSI_READ_BYTE(11);
    ACSI_READ_BYTE(12);
    ACSI_READ_BYTE(13);
    ACSI_READ_BYTE(14);
    ACSI_READ_BYTE(15);
    bytes += 16;
  }

  while(i < count) {
    ACSI_READ_BYTE(0);
    ++i;
    ++bytes;
  }

#undef ACSI_READ_BYTE

  releaseBus();

  // Restore systick
  systick_enable();

  Acsi::verboseDump(&bytes[-i], i);
  Acsi::verbose(" OK\n");
}

void DmaPort::sendDma(const uint8_t *bytes, int count) {
  Acsi::verbose("DMA send ");
  Acsi::verboseDump(&bytes[0], count);

  // Disable systick that introduces jitter.
  systick_disable();

  acquireDataBus();
  acquireDrq();

  // Unroll for speed
  int i = 0;
#define ACSI_SEND_BYTE(b) do { \
      writeData(bytes[b]); \
      DMA_TIMER->CNT = 0; \
      while(DMA_TIMER->CNT == 0); \
    } while(0)
#if ACSI_FAST_DMA
  for(i = 0; i <= count - 16; i += 16) {
    ACSI_SEND_BYTE(0);
    ACSI_SEND_BYTE(1);
    ACSI_SEND_BYTE(2);
    ACSI_SEND_BYTE(3);
    ACSI_SEND_BYTE(4);
    ACSI_SEND_BYTE(5);
    ACSI_SEND_BYTE(6);
    ACSI_SEND_BYTE(7);
    ACSI_SEND_BYTE(8);
    ACSI_SEND_BYTE(9);
    ACSI_SEND_BYTE(10);
    ACSI_SEND_BYTE(11);
    ACSI_SEND_BYTE(12);
    ACSI_SEND_BYTE(13);
    ACSI_SEND_BYTE(14);
    ACSI_SEND_BYTE(15);
    bytes += 16;
  }
#endif

  while(i < count) {
    ACSI_SEND_BYTE(0);
    ++i;
    ++bytes;
    asm volatile("nop");
  }

#undef ACSI_SEND_BYTE
  releaseBus();

  // Restore systick
  systick_enable();

  Acsi::verbose(" OK\n");
}

void DmaPort::endTransaction() {
  CS_TIMER->SR &= ~TIMER_SR_CC3IF; // Clear A1 received flag
}

void DmaPort::releaseRq() {
  GPIOA->regs->CRH = 0x44444BB4; // Set ACK, IRQ and DRQ as inputs
}

void DmaPort::releaseDataBus() {
  GPIOB->regs->CRH = 0x44444444; // Set PORTB[8:15] to input
}

void DmaPort::releaseBus() {
  releaseRq();
  releaseDataBus();
}

void DmaPort::acquireDrq() {
  // Set DRQ to high using timer PWM
  TIMER1_BASE->CNT = 2;

  // Transition through input pullup to avoid a hardware glitch
  GPIOA->regs->CRH = 0x44448BB4;

  // Enable timer PWM output to DRQ
  GPIOA->regs->CRH = 0x4444BBB4;
}

void DmaPort::acquireDataBus() {
  GPIOB->regs->CRH = 0x33333333; // Set PORTB[8:15] to 50MHz push-pull output
}

uint8_t DmaPort::waitCs() {
  CS_TIMER->SR &= ~TIMER_SR_UIF;
  while(!(CS_TIMER->SR & TIMER_SR_UIF));
  return (CS_TIMER->CCR4) >> 8;
}

uint8_t DmaPort::waitA1() {
  while(!(CS_TIMER->SR & TIMER_SR_CC3IF));
  return (CS_TIMER->CCR4) >> 8;
}

bool DmaPort::readAck() {
  return GPIOA->regs->IDR & ACK_MASK;
}

void DmaPort::pullIrq() {
  GPIOA->regs->CRH = 0x44444BB3;
}

void DmaPort::writeData(uint8_t byte) {
  GPIOB->regs->ODR = ((int)byte) << 8;
}

void DmaPort::setupDrqTimer() {
  DMA_TIMER->CR1 = TIMER_CR1_OPM;
  DMA_TIMER->CR2 = 0;
  DMA_TIMER->SMCR = 
#if ACSI_ACK_FILTER
    ((ACSI_ACK_FILTER) << 8) |
#endif
    TIMER_SMCR_ETP | TIMER_SMCR_TS_ETRF | TIMER_SMCR_SMS_EXTERNAL;
  DMA_TIMER->PSC = 0; // Prescaler
  DMA_TIMER->ARR = 65535; // Overflow (0 = counter stopped)
  DMA_TIMER->DIER = TIMER_DIER_CC3DE;
  DMA_TIMER->CCMR1 = 0;
  DMA_TIMER->CCMR2 = TIMER_CCMR2_OC4M;
  DMA_TIMER->CCER = TIMER_CCER_CC4E; // Enable output
  DMA_TIMER->EGR = TIMER_EGR_UG;
  DMA_TIMER->CCR2 = 65535; // Disable unused CC channel
  DMA_TIMER->CCR3 = 1; // Compare value
  DMA_TIMER->CCR4 = 1; // Compare value
  DMA_TIMER->CNT = 2;
  DMA_TIMER->CR1 |= TIMER_CR1_CEN;
}

void DmaPort::setupCsTimer() {
  CS_TIMER->CR1 = TIMER_CR1_URS;
  CS_TIMER->SMCR = TIMER_SMCR_SMS_ENCODER2;
  CS_TIMER->CCMR1 = TIMER_CCMR1_CC1S_INPUT_TI1
#if ACSI_CS_FILTER
                    | ((ACSI_CS_FILTER) << 4)
#endif
                    | TIMER_CCMR1_CC2S_INPUT_TI2;
  CS_TIMER->CCMR2 = TIMER_CCMR2_OC3M;
  CS_TIMER->CCER |= TIMER_CCER_CC1P | TIMER_CCER_CC2P;
  CS_TIMER->PSC = 0;
  CS_TIMER->ARR = 65535;
  CS_TIMER->DIER = TIMER_DIER_CC3DE | TIMER_DIER_UDE;
  CS_TIMER->CCR1 = 0;
  CS_TIMER->CCR2 = 0;
  CS_TIMER->CCR3 = 1; // Detects A1
  CS_TIMER->CCR4 = 0; // Receives PORTB on CS pulse
  CS_TIMER->EGR |= TIMER_EGR_UG; // Update the timer
  CS_TIMER->CR1 |= TIMER_CR1_CEN; // Enable the timer
  CS_TIMER->CNT = 0;

  // Setup DMA to copy PORTB to CCR4 on CS pulse
  dma_setup_transfer(DMA1,
                     DMA_CH5,
                     &(CS_TIMER->CCR4),
                     DMA_SIZE_16BITS,
                     &(GPIOB->regs->IDR),
                     DMA_SIZE_16BITS,
                     DMA_FROM_MEM | DMA_CIRC_MODE);
  dma_set_num_transfers(DMA1, DMA_CH5, 1);
  dma_enable(DMA1, DMA_CH5);
  dma_setup_transfer(DMA1,
                     DMA_CH7,
                     &(CS_TIMER->CCR4),
                     DMA_SIZE_16BITS,
                     &(GPIOB->regs->IDR),
                     DMA_SIZE_16BITS,
                     DMA_FROM_MEM | DMA_CIRC_MODE);
  dma_set_num_transfers(DMA1, DMA_CH7, 1);
  dma_enable(DMA1, DMA_CH7);

  // Clear A1 flag
  endTransaction();
}

void DmaPort::setupAckDmaTransfer() {
  // Setup the DMA engine to copy GPIOB to timer 1 CH1 compare value
  dma_init(DMA1);
  dma_setup_transfer(DMA1,
                     DMA_CH6,
                     &(DMA_TIMER->CCR1),
                     DMA_SIZE_16BITS,
                     &(GPIOB->regs->IDR),
                     DMA_SIZE_16BITS,
                     DMA_FROM_MEM | DMA_CIRC_MODE);
  dma_set_num_transfers(DMA1, DMA_CH6, 1);
  dma_enable(DMA1, DMA_CH6);
}

void DmaPort::setupGpio() {
  GPIOA->regs->ODR |= DRQ_MASK;
  releaseBus();
}

// vim: ts=2 sw=2 sts=2 et
