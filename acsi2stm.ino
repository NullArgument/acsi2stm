/* ACSI2STM Atari hard drive emulator
 * Copyright (C) 2019-2021 by Jean-Matthieu Coulon
 *
 * This Library is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This Library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with the program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include <libmaple/libmaple_types.h>
#include <libmaple/systick.h>
#include <libmaple/util.h>
#include <libmaple/rcc.h>
#include <libmaple/iwdg.h>
#include <boards.h>
#include <wirish.h>
#include <inttypes.h>
#include <SPI.h>
#include "Sd2CardX.h"

// Settings

// Version number shown in the device name
#define ACSI2STM_VERSION "20b"

// Set to 1 to enable extra checks in DMA transfers
// Slows down data throughput
#define ACSI_CAREFUL_DMA 1

// Set to 1 to enable debug output on the serial port
#define ACSI_DEBUG 0

// Set to 1 to enable verbose command output on the serial port
#define ACSI_VERBOSE 0

// Number of bytes per DMA transfer to dump in verbose mode
// Set to 0 to disable data dump
#define ACSI_DUMP_LEN 0

// Maximum number of blocks on the SD (limits capacity artificially)
//#define SD_MAX_BLOCKS 0x0FFFFF

// Maximum number of retries in case of SD card errors
#define SD_MAX_RETRY 3

// Watchdog duration
#define WATCHDOG_MILLIS 2000 // Milliseconds before reboot
#define WATCHDOG_TIMEOUT 50 // Milliseconds for short timeouts

// Activity LED pin. Leave undefined to remove activity LED.
#define LED LED_BUILTIN

// Pin definitions
static const int sdCs[] = {
  // List of SD card CS pins. CS pins must be on PA0 to PA4.
  // Use -1 to ignore an ID
  PA4, // ACSI ID 0
  PA3, // ACSI ID 1
  PA2, // ACSI ID 2
  PA1, // ACSI ID 3
  PA0, // ACSI ID 4
  -1,  // ACSI ID 5
  -1,  // ACSI ID 6
  -1,  // ACSI ID 7
};

// Constants

// SD card block size
#define ACSI_BLOCKSIZE 512

#define A1 PB6 // Must be on port B
#define CS PB7 // Must be on port B
#define IRQ PA8
#define DRQ PA11 // Must be on Timer1 channel output
#define ACK PA12 // Must be on Timer1 external clock
// Data pins are on PC8-PB15

// Pin masks for direct port access
#define A1_MASK  0b0000000001000000
#define CS_MASK  0b0000000010000000
#define IRQ_MASK 0b0000000100000000
#define DRQ_MASK 0b0000100000000000
#define ACK_MASK 0b0001000000000000

// Globals

class SD {
public:
  Sd2Card card;
  uint32_t blocks;
  int acsiDevId = -1;
  bool initialized = false;
  bool bootable;
  uint32_t lastBlock;
  bool lastSeek;
  int lastErr;

  bool present();
  bool init();
  bool writeBlock(int block);
  bool writeBlocks(int block, int count);
  bool readBlock(int block);
  bool readBlocks(int block, int count);
  void getId(char *target);
};
#define MAX_SD (sizeof(sdCs)/sizeof(int))
static SD sdCards[MAX_SD];
static SD *sd; // Current SD card
static uint8_t dataBuf[ACSI_BLOCKSIZE];
static uint8_t cmdBuf[11];
static int cmdLen; // Length of the last command in bytes
static uint8_t readerMask; // Mask of present SD card readers

#define LASTERR_OK 0x00
#define LASTERR_NOSECTOR 0x01
#define LASTERR_WRITEERR 0x03
#define LASTERR_OPCODE 0x20
#define LASTERR_INVADDR 0x21
#define LASTERR_INVARG 0x24
#define LASTERR_INVLUN 0x25


/* How ACSI DMA is handled (DRQ/ACK pulses and data sampling):

Expected behavior
-----------------

DRQ is generated by the STM32, it triggers a DMA transfer.
ACK is generated by the ST, it tells the STM32 when the data bus is sampled.
DRQ must go high at most 180ns after ACK goes low. Failing to do that will
abort the DMA transfer by the ST.

DMA reads (STM32 -> ST)

          ___              _________
     DRQ     |____________|
          ______________         ___
     ACK                |_______|

    DATA                        S

Data seems to be sampled when ACK goes up (marked "S").
The STM32 keeps the data up for the whole transfer (DRQ+ACK), which avoids
risks of reading invalid data.


DMA writes (ST -> STM32)

          ___              _________
     DRQ     |____________|
          ______________         ___
     ACK                |_______|

    DATA               [========]

Data is guaranteed to be available during the whole ACK pulse (marked "[==]").


STM32 implementation
--------------------

DRQ and ACK pulses are too fast to use bit banging, even with direct port
access.

The current implementation uses STM32 timers and its DMA engine to process
these signals. Data flow:
             __________
         CLK|          |CH4
  ACK ----->|  Timer1  |-----> PA11 (DRQ)
            |          |
            |          |CH1
            |          |------------
            |__________|            |
                                    |Trigger (DMA1 CH2)
                      _______     __V___     __________
                     |       |   |      |   |          |
                     | GPIOB |-->| DMA1 |-->|  Timer4  |
                     |       |   |      |   |  CH1 CC  |
                     |_______|   |______|   |__________|

 * ACK is used as Timer1 clock.
 * PA11 (DRQ) is used as a PWM output that goes up whenever Timer1 receives a clock tick.
 * Timer1 triggers a STM32 DMA transfer whenever Timer1 receives a clock tick.
 * The STM32 DMA engine copies GPIOB to Timer4 CH1 compare value.
 * Timer4 CH1 is used as a simple buffer because GPIOB is considered as memory
   by the STM32 DMA engine and memory to memory copies cannot be triggered by
   a timer, so it has to be a memory to peripheral copy. Any unused peripheral
   register can be used for this task.
 * If multiple ACK signals are received, this can be detected by having an incorrect
   counter value. This avoids silent data corruption in case of problems. This check is
   only done if ACSI_CAREFUL_DMA is enabled.
 * Timer2 (watchdog) is used to detect an ACK timeout. This is done by a software loop.


DMA read process
----------------

DMA block transfer initialization process:

 * Set Timer1 counter to a high value so DRQ will be high when enabled
 * Enable DRQ in PWM mode (high if Timer1 > 0, low if Timer1 = 0)
 * Enable Timer1

DMA byte read process:

 * Data is put on the data bus.
 * Set Timer1 counter to 0, this will pull DRQ low.
 * When ACK goes low, Timer1 counts to 1.
 * Timer1 counting will set DRQ high.
 * Wait until ACK goes high.

DMA block transfer stop process:

 * Set DRQ pin as input
 * Disable Timer1


DMA write process
-----------------

DMA block transfer initialization process:

 * Set Timer1 counter to a high value so DRQ will be high when enabled
 * Enable DRQ in PWM mode (high if Timer1 > 0, low if Timer1 = 0)
 * Enable Timer1

DMA byte write process:

 * Set Timer1 counter to 0, this will pull DRQ low.
 * When ACK goes low, Timer1 counts to 1.
 * Timer1 counting will set DRQ high.
 * Timer1 counting will trigger the STM32 DMA CH2.
 * The STM32 DMA will copy GPIOB to Timer4 CH1 compare value.
 * Wait until ACK goes high.
 * Read Timer4 CH1 compare value to get the data byte.

DMA block transfer stop process:

 * Set DRQ pin as input
 * Disable Timer1

*/


// Debug output functions

#if ACSI_DEBUG
template<typename T>
inline void acsiDbg(T txt) {
  Serial.flush();
  Serial.print(txt);
}
template<typename T, typename F>
inline void acsiDbg(T txt, F fmt) {
  Serial.flush();
  Serial.print(txt, fmt);
}
template<typename T>
inline void acsiDbgln(T txt) {
  Serial.flush();
  Serial.println(txt);
}
template<typename T, typename F>
inline void acsiDbgln(T txt, F fmt) {
  Serial.flush();
  Serial.println(txt, fmt);
}
#else
template<typename T>
inline void acsiDbg(T txt) {
}
template<typename T, typename F>
inline void acsiDbg(T txt, F fmt) {
}
template<typename T>
inline void acsiDbgln(T txt) {
}
template<typename T, typename F>
inline void acsiDbgln(T txt, F fmt) {
}
#endif


// LED control functions

#ifdef LED
static inline void ledSet(int l) {
  digitalWrite(LED, !l);
  pinMode(LED, OUTPUT);
}
static inline void ledOn() {
  ledSet(1);
}
static inline void ledOff() {
  ledSet(0);
}
#else
static inline void ledOn() {
}
static inline void ledOff() {
}
static inline void ledSet(int l) {
}
#endif

// Timer-based watchdog

void watchdogTrigger() {
  Timer2.pause();
  ledOff();

  // Reset
  iwdg_init(IWDG_PRE_4, 1);
  iwdg_feed();
  for(;;);
}

static inline void watchdogInit() {
  Timer2.pause();
  Timer2.setMode(TIMER_CH1, TIMER_OUTPUTCOMPARE);
  Timer2.setPrescaleFactor(36000);
  Timer2.setOverflow(65535);
  Timer2.setCompare(TIMER_CH1, (WATCHDOG_MILLIS) * 2);
  Timer2.attachInterrupt(TIMER_CH1, watchdogTrigger);
  Timer2.setCount(0);
  Timer2.refresh();
  Timer2.resume();
}

static inline void watchdogFeed() {
  Timer2.setCount(0);
}

static inline void watchdogPause() {
  Timer2.pause();
}

static inline void watchdogResume() {
  watchdogFeed();
  Timer2.resume();
}

// Return true if the watchdog wasn't fed for 10ms
static inline bool watchdogTimeout() {
  return Timer2.getCount() >= (WATCHDOG_TIMEOUT) * 2;
}

// Use the watchdog timer to wait for 10ms
// Required because delay() cannot be used
static void recoveryDelay() {
  watchdogFeed();
  while(!watchdogTimeout());
}

// Low level pin control

// Release IRQ and DRQ pins by putting them back to input
static inline void releaseRq() {
  TIMER1_BASE->CR1 &=~ TIMER_CR1_CEN; // Disable timer 1 to free DRQ
  GPIOA->regs->CRH = (GPIOA->regs->CRH & 0xFFF00FF0) | 0x00044004; // Set ACK, IRQ and DRQ as inputs
}

// Release data pins by putting them back to input
static inline void releaseDataBus() {
  GPIOB->regs->CRH = 0x44444444; // Set PORTB[8:15] to input
}

// Release the bus completely
static inline void releaseBus() {
  releaseRq();
  releaseDataBus();
}

// Set data pins as output
static inline void acquireDataBus() {
  GPIOB->regs->CRH = 0x33333333; // Set PORTB[8:15] to 50MHz push-pull output
}

// Write a byte to the data pins
static inline void writeData(uint8_t byte) {
  GPIOB->regs->ODR = (GPIOB->regs->ODR & 0b0000000011111111) | (((int)byte) << 8);
}

// Pull IRQ to low
static inline void pullIrq() {
  GPIOA->regs->CRH = (GPIOA->regs->CRH & 0xFFFFFFF0) | 0x00000003;
}

// Returns the value of the CS pin
static inline int getCs() {
  return GPIOB->regs->IDR & CS_MASK;
}

// Returns the value of the ACK pin
static inline int getAck() {
  return GPIOA->regs->IDR & ACK_MASK;
}

// Set the DRQ pin to output
static inline void acquireDrq() {
  // Set DRQ to high using timer PWM
  TIMER1_BASE->CNT = 2;

  // Transition through input pullup to avoid a hardware glitch
  GPIOA->regs->ODR |= DRQ_MASK;
  GPIOA->regs->CRH = (GPIOA->regs->CRH & 0xFFFF0FFF) | 0x00008000;

  // Enable timer PWM output to DRQ
  GPIOA->regs->CRH = (GPIOA->regs->CRH & 0xFFFF0FFF) | 0x0000B000;
  TIMER1_BASE->CR1 |= TIMER_CR1_CEN;
}

// Set the DRQ pin to low
static inline bool pullDrqUntilAck() {
  TIMER1_BASE->CNT = 0; // Pull DRQ to low using timer PWM

#if ACSI_CAREFUL_DMA
  // Feed watch dog for ACK timeout.
  watchdogFeed();
#endif

  // Wait until ACK ticks the timer
  while(TIMER1_BASE->CNT == 0) {
#if ACSI_CAREFUL_DMA
    if(watchdogTimeout()) {
      acsiDbgln("ACK timeout");
      return false;
    }
#endif
  }

  // The DRQ pin is attached to the timer PWM output so it automatically goes high

#if ACSI_CAREFUL_DMA
  // Wait until ACK is high (normally ACK is fast, this should never wait)
  while(!getAck()) {
    if(watchdogTimeout()) {
      acsiDbgln("ACK low timeout");
      return false;
    }
  }

  if(TIMER1_BASE->CNT != 1) {
    acsiDbg("Too many ACK pulses:");
    acsiDbgln(TIMER1_BASE->CNT);
    return false;
  }
#endif

  return true;
}

// Write a byte on the data bus, then send a pulse to the DRQ pin
// and finally wait for acknowledge.
static inline bool sendDmaByte(uint8_t byte) {
  writeData(byte); // Write the byte on the data bus
  return pullDrqUntilAck();
}

// Pulse DRQ and sample the data bus when the ST sends ACK.
static inline int readDmaByte() {
  if(!pullDrqUntilAck())
    return -1; // Error

  // The STM32 DMA engine copied GPIOB to Timer4 CH1 compare value
  return (TIMER4_BASE->CCR1) >> 8;
}

// Send some bytes from dataBuf through the port to the Atari DMA controller
static inline int sendDma(int count) {
#if ACSI_VERBOSE
  acsiDbg("Send ");
  acsiDbg(count);
  acsiDbg(" bytes");
#if ACSI_DUMP_LEN
  acsiDbg(":");
  for(int i = 0; i < min(count, ACSI_DUMP_LEN); ++i) {
    acsiDbg(' ');
    acsiDbg(dataBuf[i], HEX);
  }
  if(count > ACSI_DUMP_LEN)
    acsiDbg(" [...]");
#endif
  acsiDbgln("");
#endif

  acquireDataBus();
  acquireDrq();

  int i;
  for(i = 0; i < count && sendDmaByte(dataBuf[i]); ++i);
  releaseBus();

#if ACSI_DEBUG
  if(i != count) {
    acsiDbg("Send DMA aborted after ");
    acsiDbg(i);
    acsiDbgln(" bytes");
  }
#endif
  return i;
}

// Receive some bytes through the port from the Atari DMA controller and store them to dataBuf
static inline int readDma(int count) {
  acquireDrq();

  int i;
  for(i = 0; i < count; ++i) {
    int v = readDmaByte();
    if(v < 0) {
      acsiDbg("Read DMA aborted after ");
      acsiDbg(i);
      acsiDbgln(" bytes");
      break;
    }
    dataBuf[i] = (uint8_t)v;
  }
  releaseRq();
#if ACSI_VERBOSE
  acsiDbg("Read ");
  acsiDbg(count);
  acsiDbg(" bytes");
#if ACSI_DUMP_LEN
  acsiDbg(":");
  for(int c = 0; c < min(i, ACSI_DUMP_LEN); ++c) {
    acsiDbg(' ');
    acsiDbg(dataBuf[c], HEX);
  }
  if(i > ACSI_DUMP_LEN)
    acsiDbg(" [...]");
#endif
  if(i < count) {
    acsiDbg(" (missing ");
    acsiDbg(count - i);
    acsiDbg(" bytes)");
  }
  acsiDbgln("");
#endif
  return i;
}

// Return the current LUN for the current command
static inline int getLun() {
  if(cmdBuf[0] == 0x1F)
    return (cmdBuf[2] & 0xE0) >> 5;
  return (cmdBuf[1] & 0xE0) >> 5;
}

// Returns true if IRQ, DRQ and ACK are high
static inline bool rqReleased() {
  return (GPIOA->regs->IDR & (IRQ_MASK | DRQ_MASK | ACK_MASK)) == IRQ_MASK | DRQ_MASK | ACK_MASK;
}

// Wait for a new command and put it in cmdBuf
// All commands are always 6 bytes long
// Suspends the watchdog while waiting for a new command
// When this function exits, turns the LED on
static inline void waitCommand() {
  int b;

  watchdogPause();
  noInterrupts();
  do {
    // Read the command on the data pins along with the
    // A1 command start marker and the CS clock signal
    // This is done in a single operation because the
    // CS pulse is fast (250ns)
    while((b = GPIOB->regs->IDR) & (A1_MASK | CS_MASK));
  } while(!((1 << (b >> (8+5))) & readerMask) && rqReleased()); // Check the device ID and Ack line
  interrupts();
  watchdogResume();

  // If CS never goes up before the watchdog triggers, the cable is probably disconnected.
  while(!getCs());

  // At this point we are receiving a command targeted at a present device.

  // Select the correct SD card
  sd = &sdCards[b >> (8+5)];

  // Enable activity LED. It will be disabled by the sendStatus function
  ledOn();

  // Put the command ID in the first command buffer byte
  cmdBuf[0] = (b >> 8) & 0b00011111;

  cmdLen = cmdBuf[0] == 0x1F ? 11 : 6;

  // Read the next bytes of the command
  for(int i = 1; i < cmdLen; ++i) {
    pullIrq();
    while((b = GPIOB->regs->IDR) & (CS_MASK)); // Read data and clock at the same time
    releaseRq();
    cmdBuf[i] = b >> 8; // Write the byte
  }

  // If CS never goes up before the watchdog triggers, the cable is probably disconnected.
  while(!getCs());
}

// Send a status code and turn the status LED off
static inline void sendStatus(uint8_t s) {
  ledOff(); // We just finished processing a command: turn off activity LED

  acquireDataBus();
  writeData(s);
  pullIrq();
  while(getCs());
  releaseBus();
}

// Send a status byte that indicates the command was a success
static inline void commandSuccess() {
#if ACSI_VERBOSE
  acsiDbgln("Success");
#endif
  sd->lastErr = LASTERR_OK;
  sendStatus(0);
}

// Send a status byte that indicates an error happened
static inline void commandError() {
#if ACSI_VERBOSE
  acsiDbgln("Error");
#endif
  sendStatus(2);
}

static inline void setupDrqTimer() {
  TIMER1_BASE->CR1 = TIMER_CR1_OPM;
  TIMER1_BASE->CR2 = 0;
  TIMER1_BASE->SMCR = TIMER_SMCR_ETP | TIMER_SMCR_TS_ETRF | TIMER_SMCR_SMS_EXTERNAL;
  TIMER1_BASE->PSC = 0; // Prescaler
  TIMER1_BASE->ARR = 65535; // Overflow (0 = counter stopped)
  TIMER1_BASE->DIER = TIMER_DIER_CC1DE;
  TIMER1_BASE->CCMR1 = 0;
  TIMER1_BASE->CCMR2 = TIMER_CCMR2_OC4M;//(TIMER_CCMR2_OC4M & (0b110 << 12));
  TIMER1_BASE->CCER = /*TIMER_CCER_CC4P |*/ TIMER_CCER_CC4E; // Enable output
  TIMER1_BASE->EGR = TIMER_EGR_UG;
  TIMER1_BASE->CCR1 = 1; // Compare value
  TIMER1_BASE->CCR4 = 1; // Compare value
}

static inline void setupAckDmaTransfer()
{
  TIMER4_BASE->CR1 = 0; // Disable timer 4 to use its CCR1 register as a buffer
  TIMER1_BASE->CCR1 = 0;

  // Setup the DMA engine to copy GPIOB to timer 4 CH1 compare value
  dma_init(DMA1);
  dma_setup_transfer(DMA1,
                     DMA_CH2,
                     &(TIMER4_BASE->CCR1),
                     DMA_SIZE_16BITS,
                     &(GPIOB->regs->IDR),
                     DMA_SIZE_16BITS,
                     DMA_FROM_MEM | DMA_CIRC_MODE);
  dma_set_num_transfers(DMA1, DMA_CH2, 1);
  dma_enable(DMA1, DMA_CH2);
}

// Initialize the ACSI port
static inline void acsiInit() {
  acsiDbgln("Initializing ACSI bus ...");

  // Setup peripherals to handle ACK pulses
  setupDrqTimer();
  setupAckDmaTransfer();

  // Release all bus pins
  releaseBus();

  // Wait until ST is ready
  pinMode(CS, INPUT_PULLDOWN);
  pinMode(A1, INPUT_PULLDOWN);

  while(((GPIOB->regs->IDR) | ~(A1_MASK | CS_MASK)) != ~0)
    watchdogFeed();
  acsiDbgln("ACSI bus ready");

  pinMode(CS, INPUT);
  pinMode(A1, INPUT);
}

// Initialize the SD card
bool SD::init() {
  acsiDbg("Initializing SD card ");
  acsiDbgln(acsiDevId);
  systick_enable(); // Needed for SD timeout
  for(int tries = 0; tries < SD_MAX_RETRY && !(initialized = card.init(SPI_FULL_SPEED, sdCs[acsiDevId])); ++tries, watchdogFeed());
  systick_disable();

  if(initialized) {
    blocks = card.cardSize();
    acsiDbg("Size: ");
    acsiDbg(blocks / 2048);
    acsiDbg("MB - ");
    acsiDbg(blocks);
    acsiDbg(" blocks");
#if SD_MAX_BLOCKS
    if(blocks > SD_MAX_BLOCKS) {
      blocks = SD_MAX_BLOCKS;
      acsiDbg(" (capped to ");
      acsiDbg(blocks / 2048);
      acsiDbg("MB)");
    }
#endif
    acsiDbgln("");

    // Detect partition type
    card.readBlock(0, dataBuf);
    int checksum = 0;
    for(int i = 0; i < ACSI_BLOCKSIZE; i += 2) {
      checksum += ((int)dataBuf[i] << 8) + (dataBuf[i+1]);
    }
    if((checksum & 0xFFFF) == 0x1234) {
      // Valid Atari boot sector
      acsiDbgln("SD card is bootable");
      bootable = true;
    }

  }
  else
    acsiDbgln("Cannot init SD card");

  return initialized;
}

// Write a block from dataBuf into the SD card
inline bool SD::writeBlock(int block) {
  int tries = SD_MAX_RETRY;

  // Receive data to write
  if(readDma(ACSI_BLOCKSIZE) != ACSI_BLOCKSIZE)
    return false;

  // Write data to the SD card
  while(!card.writeBlock(block, dataBuf) && tries-- > 0) {
    acsiDbg("Retry write on block ");
    acsiDbgln(block, HEX);
    recoveryDelay(); // Wait a bit to leave some recovery time for the SD card
    watchdogFeed();
    // After a certain amount of retries, reinit the SD card completely
    if(tries <= SD_MAX_RETRY / 2 && !init()) {
      return false;
    }
  }

  return tries > 0;
}

// Process a write block command
inline bool SD::writeBlocks(int block, int count) {
  if(block + count - 1 >= blocks) {
    sd->lastErr = LASTERR_INVADDR;
    return false; // Block out of range
  }
  // For each requested block
  for(int b = count; b--; block++) {
    watchdogFeed();
    // Do the actual write operation
    if(!writeBlock(block)) {
      // SD write error
      return false;
    }
  }
  return true;
}

// Read a block from the SD card and store it to dataBuf
inline bool SD::readBlock(int block) {
  int tries = SD_MAX_RETRY;
  while(!card.readBlock(block, dataBuf) && tries-- > 0) {
    acsiDbg("Retry read on block ");
    acsiDbgln(block, HEX);
    recoveryDelay(); // Wait a bit to leave some recovery time for the SD card
    watchdogFeed();
    // After a certain amount of retries, reinit the SD card completely
    if(tries <= SD_MAX_RETRY / 2 && !init()) {
      // SD write error
      sd->lastErr = LASTERR_NOSECTOR;
      return false;
    }
  }
  if(tries == 0)
    return false; // Retried too many times
  
  return sendDma(ACSI_BLOCKSIZE) == ACSI_BLOCKSIZE; // Send read data
}

// Process a read block command
inline bool SD::readBlocks(int block, int count) {
  if(block + count - 1 >= blocks) {
    sd->lastErr = LASTERR_INVADDR;
    return false; // Block out of range
  }
  // For each requested block
  for(int blocks = count; blocks--; block++) {
    watchdogFeed();
    // Do the actual read operation
    if(!readBlock(block)) {
      return false;
    }
  }
  return true;
}

void SD::getId(char *target) {

  int sz = blocks / 2048;
  char unit = 'M';
  char boot0 = ' ';
  char boot1 = ' ';

  // Write SD card size
  if(blocks >= 2048*10240) { // Size in GB if size >= 10G
    sz = blocks / (2048*1024);
    unit = 'G';
  }

  // Add the Atari logo at the end if the SD is detected as bootable
  if(bootable) {
    boot0 = 0x0E;
    boot1 = 0x0F;
  }

  sprintf(target, "ACSI2STM SD %1d %4d %cB %c%cv" ACSI2STM_VERSION, acsiDevId, sz, unit, boot0, boot1);

  acsiDbg("SD ");
  acsiDbg(acsiDevId);
  acsiDbg(" ID ='");
  acsiDbg(target);
  acsiDbgln("'");
}

// Main setup function
void setup() {
#ifdef LED
  pinMode(LED, OUTPUT);
  ledOn(); // Enable LED on power up to signal init activity.
#endif
#if ACSI_DEBUG
  Serial.begin(115200); // Init the serial port only if needed

  // Send a few characters to synchronize autoconfigured USB-serial dongles.
  acsiDbgln("");
  delay(50);
  acsiDbgln("");
  delay(100);
#endif

  delay(50); // Leave some time for SD cards to boot and power to stabilize

  acsiDbgln("-----------------------");
  acsiDbgln("ACSI2STM SD bridge v" ACSI2STM_VERSION);
  acsiDbgln("-----------------------");
  acsiDbgln("");
  
  // Initialize SD cards
  int sdCount = 0;
  for(int i = 0; i < MAX_SD; ++i) {
    if(sdCs[i] == -1)
      continue;
    sdCards[i].acsiDevId = i;
    if(sdCards[i].init()) {
      readerMask |= 1 << i;
      sdCount++;
    }
  }

  // Disable systick that introduces jitter. delay() does not work because of this.
  systick_disable();

  // Initialize the watchdog timer
  watchdogInit();

  acsiDbg(sdCount);
  acsiDbgln(" SD cards found");

  // Initialize the ACSI port
  acsiInit();

  acsiDbgln("");
  acsiDbgln("--- Ready to go ---");
  acsiDbgln("");

  ledOff();
}

// Main loop
void loop() {
  waitCommand(); // Wait for the next command arriving in cmdBuf

  if(!sd->initialized) {
    if(!sd->init()) {
      commandError();
      return;
    }
  }

#if ACSI_VERBOSE
  acsiDbg("Command ");
  for(int i = 0; i < cmdLen; ++i) {
    acsiDbg(' ');
    acsiDbg(cmdBuf[i], HEX);
  }
  acsiDbgln("");
#endif

  switch(cmdBuf[0]) {
  default:
    // Check LUN
    if(getLun() > 0) {
      sd->lastErr = LASTERR_INVLUN;
      commandError();
      return;
    }
  case 0x03: // Request Sense
  case 0x12: // Inquiry
    break;
  }

  // Execute the command
  switch(cmdBuf[0]) {
  default: // Unknown command
    acsiDbg("Unknown command ");
    for(int i = 0; i < cmdLen; ++i) {
      acsiDbg(' ');
      acsiDbg(cmdBuf[i], HEX);
    }
    acsiDbgln("");
    sd->lastSeek = false;
    commandError();
    return;
  case 0x0D: // Correction
  case 0x15: // Mode select
  case 0x1B: // Ship
    // Always succeed
    sd->lastSeek = false;
    commandSuccess();
    return;
  case 0x04: // Format drive
  case 0x05: // Verify track
  case 0x06: // Format track
    sd->lastSeek = false;
    // fall through case
  case 0x00: // Test drive ready
    // Reinitialize the SD card
    if(!sd->init()) {
      commandError();
      return;
    }
    else
      commandSuccess();
    return;
  case 0x03: // Request Sense
    // Reinitialize the SD card
    if(!sd->init()) {
      commandError();
      return;
    }
    // Fill the response with zero bytes
    for(int b = 0; b < cmdBuf[4]; ++b) {
      dataBuf[b] = 0;
    }
    if(cmdBuf[4] <= 4) {
      dataBuf[0] = sd->lastErr;
      if(sd->lastSeek) {
        dataBuf[0] |= 0x80;
        dataBuf[1] = (sd->lastBlock >> 16) & 0xFF;
        dataBuf[2] = (sd->lastBlock >> 8) & 0xFF;
        dataBuf[3] = (sd->lastBlock) & 0xFF;
      }
    } else {
      // Build long response in dataBuf
      dataBuf[0] = 0x70;
      if(sd->lastSeek) {
        dataBuf[0] |= 0x80;
        dataBuf[4] = (sd->lastBlock >> 16) & 0xFF;
        dataBuf[5] = (sd->lastBlock >> 8) & 0xFF;
        dataBuf[6] = (sd->lastBlock) & 0xFF;
      }
      switch(sd->lastErr) {
      case LASTERR_OK:
        dataBuf[2] = 0;
        break;
      case LASTERR_OPCODE:
      case LASTERR_INVADDR:
      case LASTERR_INVARG:
      case LASTERR_INVLUN:
        dataBuf[2] = 5;
        break;
      default:
        dataBuf[2] = 4;
        break;
      }
      dataBuf[7] = 14;
      dataBuf[12] = sd->lastErr;
      dataBuf[19] = (sd->lastBlock >> 16) & 0xFF;
      dataBuf[20] = (sd->lastBlock >> 8) & 0xFF;
      dataBuf[21] = (sd->lastBlock) & 0xFF;
    }
    // Send the response
    sendDma(cmdBuf[4]);
    
    commandSuccess();
    return;
  case 0x08: // Read block
    // Compute the block number
    sd->lastBlock = (((int)cmdBuf[1]) << 16) | (((int)cmdBuf[2]) << 8) | (cmdBuf[3]);
    sd->lastSeek = true;

    // Do the actual read operation
    if(sd->readBlocks(sd->lastBlock, cmdBuf[4]))
      commandSuccess();
    else
      commandError();
    return;
  case 0x0A: // Write block
    // Compute the block number
    sd->lastBlock = (((int)cmdBuf[1]) << 16) | (((int)cmdBuf[2]) << 8) | (cmdBuf[3]);
    sd->lastSeek = true;

    // Do the actual write operation
    if(sd->writeBlocks(sd->lastBlock, cmdBuf[4]))
      commandSuccess();
    else
      commandError();
    return;
  case 0x0B: // Seek
    // Reinitialize the SD card
    if(!sd->init()) {
      sd->lastErr = LASTERR_INVADDR;
      commandError();
      return;
    }
    sd->lastBlock = (((int)cmdBuf[1]) << 16) | (((int)cmdBuf[2]) << 8) | (cmdBuf[3]);
    sd->lastSeek = true;
    if(sd->lastBlock >= sd->blocks) {
      sd->lastErr = LASTERR_INVADDR;
      commandError();
    } else
      commandSuccess();
    return;
  case 0x12: // Inquiry
    // Reinitialize the SD card
    if(!sd->init()) {
      commandError();
      return;
    }
    for(uint8_t b = 0; b < cmdBuf[4]; ++b) {
      dataBuf[b] = 0;
    }

    if(getLun() > 0)
      dataBuf[0] = 0x7F; // Unsupported LUN
    dataBuf[2] = 1; // ACSI version
    dataBuf[4] = 31; // Data length
    
    // Build the product string with the SD card size
    sd->getId((char *)dataBuf + 8);
    
    sendDma(cmdBuf[4]);

    sd->lastSeek = false;
    commandSuccess();
    return;
  case 0x1A: // Mode sense
    sd->lastSeek = false;
    switch(cmdBuf[2]) { // Sub-command
    case 0x00:
      for(uint8_t b = 0; b < 16; ++b) {
        dataBuf[b] = 0;
      }
      // Values got from the Hatari emulator
      dataBuf[1] = 14;
      dataBuf[3] = 8;
      // Send the number of blocks of the SD card
      dataBuf[5] = (sd->blocks >> 16) & 0xFF;
      dataBuf[6] = (sd->blocks >> 8) & 0xFF;
      dataBuf[7] = (sd->blocks) & 0xFF;
      // Sector size middle byte
      dataBuf[10] = 2;
      sendDma(16);
      break;
    case 0x04:
      for(uint8_t b = 0; b < 24; ++b) {
        dataBuf[b] = 0;
      }
      // Values got from the Hatari emulator
      dataBuf[0] = 4;
      dataBuf[1] = 22;
      // Send the number of blocks in CHS format
      dataBuf[2] = (sd->blocks >> 23) & 0xFF;
      dataBuf[3] = (sd->blocks >> 15) & 0xFF;
      dataBuf[4] = (sd->blocks >> 7) & 0xFF;
      // Hardcode 128 heads
      dataBuf[5] = 128;
      sendDma(24);
      break;
    default:
      if(getLun() == 0)
        sd->lastErr = LASTERR_INVARG;
      commandError();
      return;
    }
    commandSuccess();
    return;
  case 0x1F: // ICD extended command
    switch(cmdBuf[1]) { // Sub-command
    case 0x25: // Read capacity
      // Reinitialize the SD card
      if(!sd->init()) {
        commandError();
        return;
      }
      // Send the number of blocks of the SD card
      dataBuf[0] = (sd->blocks >> 24) & 0xFF;
      dataBuf[1] = (sd->blocks >> 16) & 0xFF;
      dataBuf[2] = (sd->blocks >> 8) & 0xFF;
      dataBuf[3] = (sd->blocks) & 0xFF;
      // Send the block size (which is always 512)
      dataBuf[4] = 0x00;
      dataBuf[5] = 0x00;
      dataBuf[6] = 0x02;
      dataBuf[7] = 0x00;
      
      sendDma(8);
      
      commandSuccess();
      return;
    case 0x28: // Read blocks
      {
        // Compute the block number
        int block = (((int)cmdBuf[3]) << 24) | (((int)cmdBuf[4]) << 16) | (((int)cmdBuf[5]) << 8) | (cmdBuf[6]);
        int count = (((int)cmdBuf[8]) << 8) | (cmdBuf[9]);
  
        // Do the actual read operation
        if(sd->readBlocks(block, count))
          commandSuccess();
        else
          commandError();
      }
      return;
    case 0x2A: // Write blocks
      {
        // Compute the block number
        int block = (((int)cmdBuf[3]) << 24) | (((int)cmdBuf[4]) << 16) | (((int)cmdBuf[5]) << 8) | (cmdBuf[6]);
        int count = (((int)cmdBuf[8]) << 8) | (cmdBuf[9]);
  
        // Do the actual write operation
        if(sd->writeBlocks(block, count))
          commandSuccess();
        else
          commandError();
      }
      return;
    }
  }
}
